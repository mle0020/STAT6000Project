---
title: "Stat6000 Project"
output:
  html_document:
    highlight: tango
    theme: spacelab
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries,message=FALSE,warning=FALSE}
library(ggplot2)
library(caret)
library(tidyverse)
library(ISLR)
library(randomForest)
```


#Get Data Ready

First we need to read in our data set

```{r data set}
#below is one way to read in the data
#winequality.red <- read.csv("~/GitHub/STAT6000Project/winequality-red.csv", sep=";")

#This is another way to read in the data and the one that 
#we will use for the project
winequality.red<-read.csv("winequality-red.csv",sep = ";")
head(winequality.red)
```

Now we need to make sure there are no empty values or missing values


```{r fix data}
summary(complete.cases(winequality.red))
```
Doing this check shows us that we do not have any missing values in our data 
set.
Now lets do some summary statistics and plots of the response 
value of quality.

```{r data check}
summary(winequality.red)
#box plot of the data
ggplot(data=winequality.red, mapping = aes(y=quality))+
  geom_boxplot()+scale_y_continuous("Quality")+theme_bw()
#bar graph of the data
ggplot(data = winequality.red) + 
  geom_bar(mapping = aes(x = quality))+
  geom_vline(xintercept=mean(winequality.red$quality), color="purple")+
  geom_vline(xintercept=median(winequality.red$quality), color="cyan")+theme_bw()

winequality.red$Quality <- rep(0,dim(winequality.red)[1])
winequality.red$Quality[winequality.red$quality>6.5] <- "1"
winequality.red$Quality <- as.factor(winequality.red$Quality)
wine<-winequality.red[,c(1:11,13)] ###dataset for below steps###
head(wine)
table(winequality.red$Quality)

par(mfrow=c(2,3))
for (v in 1:11) {
  boxplot(wine[,v]~Quality,data = wine,ylab = colnames(wine)[v] )
}

#Now we want to make a column we could potentially use for logistic regression
logstuff<-rep("No",dim(winequality.red)[1])
logstuff[winequality.red$quality>6.5]<-"Yes"

#this adds the column to our data set
winequality.red <- winequality.red %>%
  mutate(
    GoodWine = logstuff
  )
    

```

#Cross Validation for Classification
For classification problems, cross validation works similar to how it is used
in linear regression. Instead of using MSE, we use the number of 
misclassified observations to quantify test error. 

Cross validation is a method that checks how well the model fits test data.
It is used specifically when there is not a data set that is specifically used
as test data. Cross Validation allows us to use portions of the training data
as test data instead. 

For this project, we need to test and build each method with the same 
training and test data sets. We will use k-fold cross validation with a
k of 10. The code used to split the data can be found in the following section.

```{r k-fold cv} 
#set the seed so we get the same groups each time
set.seed(1)

#this section of code uses the r package caret to create 
#10 folds of the numbers from 1 to 1599. So if you do not have
#the caret package, you will need to install it. 

flds <- createFolds(c(1:1599), k = 10, list = TRUE, returnTrain = FALSE)
names(flds)[1] <- "train"

#Once I created the folds of the numbers between 1 and 1599, I used these to 
#pick the corresponding columns of the data frame. These can be used for 
#all the following methods to calculate test error using the k-fold 
#method of cross validation

trainset <- winequality.red[flds$train,]
fold2 <- winequality.red[flds$Fold02,]
fold3 <- winequality.red[flds$Fold03,]
fold4 <- winequality.red[flds$Fold04,]
fold5 <- winequality.red[flds$Fold05,]
fold6 <- winequality.red[flds$Fold06,]
fold7 <- winequality.red[flds$Fold07,]
fold8 <- winequality.red[flds$Fold08,]
fold9 <- winequality.red[flds$Fold09,]
fold10 <- winequality.red[flds$Fold10,]

```


# - Madison


```{r QDA}


```


#LDA - Chung Ho



```{r LDA}

```

#KNN - Mike



```{r KNN}

```



#Random Forest - Shao-Wei

```{r Random Forest}
same.data.rf.error<-data.frame(sample=rep(1:10,each=11),m=rep(1:11,times=10),error=NA)
for (i in 1:10) {
  split<-data.frame(flds[i])
  split<-as.vector(split[,1])
  test<-wine[split,]
  y.test<-test[,12]
  x.test<- test[,1:11]
  train<-wine[-split,]
  for (m in 1:11) {
      RF<-randomForest(formula = Quality ~ ., data = train, xtest = x.test , ytest = y.test , ntree = 500, mtry=m)
      same.data.rf.error[11*(i-1)+m,3]<-RF$test$err.rate[500,1]
  }
}

#mean comparisonin in different m

ave.rf.error<-data.frame(sample=rep("Average"),m=c(1:11),error=rep(NA,11))
for (i in 1:11) {
  ave.rf.error[i,3]<-mean(same.data.rf.error[same.data.rf.error$m==i,3])
}
rf.error<-rbind(same.data.rf.error,ave.rf.error)
rf.error$sample<-as.factor(rf.error$sample)
rf.error<-cbind(rf.error,average=c(rep(0,110),rep(1,11)))
ggplot(rf.error,aes(x=m , y = error,color=sample,linetype=as.factor(average))) +
  geom_line() + guides(linetype=FALSE) + theme_bw()

### RF with m=4 ###
accu<-matrix(NA,10,1)
accu1<-matrix(NA,10,1)
accu2<-matrix(NA,10,1)
par(mfrow=c(2,5))
for (i in 1:10) {
  split<-data.frame(flds[i])
  split<-as.vector(split[,1])
  test<-wine[split,]
  y.test<-test[,12]
  x.test<- test[,1:11]
  train<-wine[-split,]
  RF<-randomForest(formula = Quality ~ ., data = train, xtest = x.test , ytest = y.test , ntree = 500, mtry=3)
  accu[i,]<-sum(test[,12]==RF$test$predicted)/length(test[,12]) #overall accuracy
  importance(RF)
  varImpPlot(RF, sort = TRUE)
}
mean(accu)
for (i in 1:10) {
  split<-data.frame(flds[i])
  split<-as.vector(split[,1])
  test<-wine[split,]
  y.test<-test[,12]
  x.test<- test[,-c(9,12)]
  train<-wine[-split,]
  RF<-randomForest(formula = Quality ~ .-pH, data = train, xtest = x.test , ytest = y.test , ntree = 500, mtry=3)
  accu1[i,]<-sum(test[,12]==RF$test$predicted)/length(test[,12]) #overall accuracy
}
mean(accu1)
for (i in 1:10) {
  split<-data.frame(flds[i])
  split<-as.vector(split[,1])
  test<-wine[split,]
  y.test<-test[,12]
  x.test<- test[,-c(6,12)]
  train<-wine[-split,]
  RF<-randomForest(formula = Quality ~ .-free.sulfur.dioxide, data = train, xtest = x.test , ytest = y.test , ntree = 500, mtry=3)
  accu2[i,]<-sum(test[,12]==RF$test$predicted)/length(test[,12]) #overall accuracy
}
mean(accu2)
```






